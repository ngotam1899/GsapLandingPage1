{"ast":null,"code":"var _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\"use strict\";\n\nexports.__esModule = true;\nexports.defaultHead = defaultHead;\nexports[\"default\"] = void 0;\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _sideEffect = _interopRequireDefault(require(\"./side-effect\"));\n\nvar _ampContext = require(\"./amp-context\");\n\nvar _headManagerContext = require(\"./head-manager-context\");\n\nvar _amp = require(\"./amp\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj[\"default\"] = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction defaultHead() {\n  var inAmpMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  var head = [/*#__PURE__*/_react[\"default\"].createElement(\"meta\", {\n    charSet: \"utf-8\"\n  })];\n\n  if (!inAmpMode) {\n    head.push( /*#__PURE__*/_react[\"default\"].createElement(\"meta\", {\n      name: \"viewport\",\n      content: \"width=device-width\"\n    }));\n  }\n\n  return head;\n}\n\nfunction onlyReactElement(list, child) {\n  // React children can be \"string\" or \"number\" in this case we ignore them for backwards compat\n  if (typeof child === 'string' || typeof child === 'number') {\n    return list;\n  } // Adds support for React.Fragment\n\n\n  if (child.type === _react[\"default\"].Fragment) {\n    return list.concat(_react[\"default\"].Children.toArray(child.props.children).reduce(function (fragmentList, fragmentChild) {\n      if (typeof fragmentChild === 'string' || typeof fragmentChild === 'number') {\n        return fragmentList;\n      }\n\n      return fragmentList.concat(fragmentChild);\n    }, []));\n  }\n\n  return list.concat(child);\n}\n\nvar METATYPES = ['name', 'httpEquiv', 'charSet', 'itemProp'];\n/*\nreturns a function for filtering head child elements\nwhich shouldn't be duplicated, like <title/>\nAlso adds support for deduplicated `key` properties\n*/\n\nfunction unique() {\n  var keys = new Set();\n  var tags = new Set();\n  var metaTypes = new Set();\n  var metaCategories = {};\n  return function (h) {\n    var isUnique = true;\n\n    if (h.key && typeof h.key !== 'number' && h.key.indexOf('$') > 0) {\n      var key = h.key.slice(h.key.indexOf('$') + 1);\n\n      if (keys.has(key)) {\n        isUnique = false;\n      } else {\n        keys.add(key);\n      }\n    } // eslint-disable-next-line default-case\n\n\n    switch (h.type) {\n      case 'title':\n      case 'base':\n        if (tags.has(h.type)) {\n          isUnique = false;\n        } else {\n          tags.add(h.type);\n        }\n\n        break;\n\n      case 'meta':\n        for (var i = 0, len = METATYPES.length; i < len; i++) {\n          var metatype = METATYPES[i];\n          if (!h.props.hasOwnProperty(metatype)) continue;\n\n          if (metatype === 'charSet') {\n            if (metaTypes.has(metatype)) {\n              isUnique = false;\n            } else {\n              metaTypes.add(metatype);\n            }\n          } else {\n            var category = h.props[metatype];\n            var categories = metaCategories[metatype] || new Set();\n\n            if (categories.has(category)) {\n              isUnique = false;\n            } else {\n              categories.add(category);\n              metaCategories[metatype] = categories;\n            }\n          }\n        }\n\n        break;\n    }\n\n    return isUnique;\n  };\n}\n/**\n*\n* @param headElements List of multiple <Head> instances\n*/\n\n\nfunction reduceComponents(headElements, props) {\n  return headElements.reduce(function (list, headElement) {\n    var headElementChildren = _react[\"default\"].Children.toArray(headElement.props.children);\n\n    return list.concat(headElementChildren);\n  }, []).reduce(onlyReactElement, []).reverse().concat(defaultHead(props.inAmpMode)).filter(unique()).reverse().map(function (c, i) {\n    var key = c.key || i;\n\n    if (process.env.__NEXT_OPTIMIZE_FONTS && !props.inAmpMode) {\n      if (c.type === 'link' && c.props['href'] && // TODO(prateekbh@): Replace this with const from `constants` when the tree shaking works.\n      ['https://fonts.googleapis.com/css'].some(function (url) {\n        return c.props['href'].startsWith(url);\n      })) {\n        var newProps = _objectSpread({}, c.props || {});\n\n        newProps['data-href'] = newProps['href'];\n        newProps['href'] = undefined;\n        return /*#__PURE__*/_react[\"default\"].cloneElement(c, newProps);\n      }\n    }\n\n    return /*#__PURE__*/_react[\"default\"].cloneElement(c, {\n      key: key\n    });\n  });\n}\n/**\n* This component injects elements to `<head>` of your page.\n* To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.\n*/\n\n\nfunction Head(_ref) {\n  var children = _ref.children;\n  var ampState = (0, _react.useContext)(_ampContext.AmpStateContext);\n  var headManager = (0, _react.useContext)(_headManagerContext.HeadManagerContext);\n  return /*#__PURE__*/_react[\"default\"].createElement(_sideEffect[\"default\"], {\n    reduceComponentsToState: reduceComponents,\n    headManager: headManager,\n    inAmpMode: (0, _amp.isInAmpMode)(ampState)\n  }, children);\n} // TODO: Remove in the next major release\n\n\n_c = Head;\n\nHead.rewind = function () {};\n\nvar _default = Head;\nexports[\"default\"] = _default;\n\nvar _c;\n\n$RefreshReg$(_c, \"Head\");","map":{"version":3,"sources":["../../../next-server/lib/head.tsx"],"names":["child","type","tags","metaTypes","metaCategories","h","isUnique","keys","reduceComponents","headElements","list","headElement","headElementChildren","React","Children","children","concat","onlyReactElement","reverse","defaultHead","props","inAmpMode","some","c","startsWith","newProps","undefined","cloneElement","key","ampState","AmpStateContext","headManager","HeadManagerContext","Head"],"mappings":"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","sourcesContent":["import React, { useContext } from 'react'\nimport Effect from './side-effect'\nimport { AmpStateContext } from './amp-context'\nimport { HeadManagerContext } from './head-manager-context'\nimport { isInAmpMode } from './amp'\n\ntype WithInAmpMode = {\n  inAmpMode?: boolean\n}\n\nexport function defaultHead(inAmpMode = false): JSX.Element[] {\n  const head = [<meta charSet=\"utf-8\" />]\n  if (!inAmpMode) {\n    head.push(<meta name=\"viewport\" content=\"width=device-width\" />)\n  }\n  return head\n}\n\nfunction onlyReactElement(\n  list: Array<React.ReactElement<any>>,\n  child: React.ReactChild\n): Array<React.ReactElement<any>> {\n  // React children can be \"string\" or \"number\" in this case we ignore them for backwards compat\n  if (typeof child === 'string' || typeof child === 'number') {\n    return list\n  }\n  // Adds support for React.Fragment\n  if (child.type === React.Fragment) {\n    return list.concat(\n      React.Children.toArray(child.props.children).reduce(\n        (\n          fragmentList: Array<React.ReactElement<any>>,\n          fragmentChild: React.ReactChild\n        ): Array<React.ReactElement<any>> => {\n          if (\n            typeof fragmentChild === 'string' ||\n            typeof fragmentChild === 'number'\n          ) {\n            return fragmentList\n          }\n          return fragmentList.concat(fragmentChild)\n        },\n        []\n      )\n    )\n  }\n  return list.concat(child)\n}\n\nconst METATYPES = ['name', 'httpEquiv', 'charSet', 'itemProp']\n\n/*\n returns a function for filtering head child elements\n which shouldn't be duplicated, like <title/>\n Also adds support for deduplicated `key` properties\n*/\nfunction unique() {\n  const keys = new Set()\n  const tags = new Set()\n  const metaTypes = new Set()\n  const metaCategories: { [metatype: string]: Set<string> } = {}\n\n  return (h: React.ReactElement<any>) => {\n    let isUnique = true\n\n    if (h.key && typeof h.key !== 'number' && h.key.indexOf('$') > 0) {\n      const key = h.key.slice(h.key.indexOf('$') + 1)\n      if (keys.has(key)) {\n        isUnique = false\n      } else {\n        keys.add(key)\n      }\n    }\n\n    // eslint-disable-next-line default-case\n    switch (h.type) {\n      case 'title':\n      case 'base':\n        if (tags.has(h.type)) {\n          isUnique = false\n        } else {\n          tags.add(h.type)\n        }\n        break\n      case 'meta':\n        for (let i = 0, len = METATYPES.length; i < len; i++) {\n          const metatype = METATYPES[i]\n          if (!h.props.hasOwnProperty(metatype)) continue\n\n          if (metatype === 'charSet') {\n            if (metaTypes.has(metatype)) {\n              isUnique = false\n            } else {\n              metaTypes.add(metatype)\n            }\n          } else {\n            const category = h.props[metatype]\n            const categories = metaCategories[metatype] || new Set()\n            if (categories.has(category)) {\n              isUnique = false\n            } else {\n              categories.add(category)\n              metaCategories[metatype] = categories\n            }\n          }\n        }\n        break\n    }\n\n    return isUnique\n  }\n}\n\n/**\n *\n * @param headElements List of multiple <Head> instances\n */\nfunction reduceComponents(\n  headElements: Array<React.ReactElement<any>>,\n  props: WithInAmpMode\n) {\n  return headElements\n    .reduce(\n      (list: React.ReactChild[], headElement: React.ReactElement<any>) => {\n        const headElementChildren = React.Children.toArray(\n          headElement.props.children\n        )\n        return list.concat(headElementChildren)\n      },\n      []\n    )\n    .reduce(onlyReactElement, [])\n    .reverse()\n    .concat(defaultHead(props.inAmpMode))\n    .filter(unique())\n    .reverse()\n    .map((c: React.ReactElement<any>, i: number) => {\n      const key = c.key || i\n      if (process.env.__NEXT_OPTIMIZE_FONTS && !props.inAmpMode) {\n        if (\n          c.type === 'link' &&\n          c.props['href'] &&\n          // TODO(prateekbh@): Replace this with const from `constants` when the tree shaking works.\n          ['https://fonts.googleapis.com/css'].some((url) =>\n            c.props['href'].startsWith(url)\n          )\n        ) {\n          const newProps = { ...(c.props || {}) }\n          newProps['data-href'] = newProps['href']\n          newProps['href'] = undefined\n          return React.cloneElement(c, newProps)\n        }\n      }\n      return React.cloneElement(c, { key })\n    })\n}\n\n/**\n * This component injects elements to `<head>` of your page.\n * To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.\n */\nfunction Head({ children }: { children: React.ReactNode }) {\n  const ampState = useContext(AmpStateContext)\n  const headManager = useContext(HeadManagerContext)\n  return (\n    <Effect\n      reduceComponentsToState={reduceComponents}\n      headManager={headManager}\n      inAmpMode={isInAmpMode(ampState)}\n    >\n      {children}\n    </Effect>\n  )\n}\n\n// TODO: Remove in the next major release\nHead.rewind = () => {}\n\nexport default Head\n"]},"metadata":{},"sourceType":"script"}