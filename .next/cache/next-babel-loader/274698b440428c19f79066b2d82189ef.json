{"ast":null,"code":"var _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\n\n/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports[\"default\"] = exports.looseToArray = void 0;\n\nvar _mitt = _interopRequireDefault(require(\"../next-server/lib/mitt\"));\n\nvar _router = require(\"../next-server/lib/router/router\");\n\nvar _escapePathDelimiters = _interopRequireDefault(require(\"../next-server/lib/router/utils/escape-path-delimiters\"));\n\nvar _getAssetPathFromRoute = _interopRequireDefault(require(\"../next-server/lib/router/utils/get-asset-path-from-route\"));\n\nvar _isDynamic = require(\"../next-server/lib/router/utils/is-dynamic\");\n\nvar _parseRelativeUrl = require(\"../next-server/lib/router/utils/parse-relative-url\");\n\nvar _querystring = require(\"../next-server/lib/router/utils/querystring\");\n\nvar _routeMatcher = require(\"../next-server/lib/router/utils/route-matcher\");\n\nvar _routeRegex = require(\"../next-server/lib/router/utils/route-regex\");\n\nvar looseToArray = function looseToArray(input) {\n  return [].slice.call(input);\n};\n\nexports.looseToArray = looseToArray;\n\nfunction getInitialStylesheets() {\n  return looseToArray(document.styleSheets).filter(function (el) {\n    return el.ownerNode && el.ownerNode.tagName === 'LINK' && el.ownerNode.hasAttribute('data-n-p');\n  }).map(function (sheet) {\n    return {\n      href: sheet.ownerNode.getAttribute('href'),\n      text: looseToArray(sheet.cssRules).map(function (r) {\n        return r.cssText;\n      }).join('')\n    };\n  });\n}\n\nfunction hasRel(rel, link) {\n  try {\n    link = document.createElement('link');\n    return link.relList.supports(rel);\n  } catch (_unused) {}\n}\n\nfunction pageLoadError(route) {\n  return (0, _router.markLoadingError)(new Error(\"Error loading \".concat(route)));\n}\n\nvar relPrefetch = hasRel('preload') && !hasRel('prefetch') ? // https://caniuse.com/#feat=link-rel-preload\n// macOS and iOS (Safari does not support prefetch)\n'preload' : // https://caniuse.com/#feat=link-rel-prefetch\n// IE 11, Edge 12+, nearly all evergreen\n'prefetch';\nvar relPreload = hasRel('preload') ? 'preload' : relPrefetch;\nvar relPreloadStyle = 'fetch';\nvar hasNoModule = ('noModule' in document.createElement('script'));\n\nfunction normalizeRoute(route) {\n  if (route[0] !== '/') {\n    throw new Error(\"Route name should start with a \\\"/\\\", got \\\"\".concat(route, \"\\\"\"));\n  }\n\n  if (route === '/') return route;\n  return route.replace(/\\/$/, '');\n}\n\nfunction appendLink(href, rel, as, link) {\n  return new Promise(function (res, rej) {\n    link = document.createElement('link'); // The order of property assignment here is intentional:\n\n    if (as) link.as = as;\n    link.rel = rel;\n    link.crossOrigin = process.env.__NEXT_CROSS_ORIGIN;\n    link.onload = res;\n    link.onerror = rej; // `href` should always be last:\n\n    link.href = href;\n    document.head.appendChild(link);\n  });\n}\n\nfunction loadScript(url) {\n  return new Promise(function (res, rej) {\n    var script = document.createElement('script');\n\n    if (process.env.__NEXT_MODERN_BUILD && hasNoModule) {\n      script.type = 'module';\n    }\n\n    script.crossOrigin = process.env.__NEXT_CROSS_ORIGIN;\n    script.src = url;\n    script.onload = res;\n\n    script.onerror = function () {\n      return rej(pageLoadError(url));\n    };\n\n    document.body.appendChild(script);\n  });\n}\n\nvar PageLoader = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function PageLoader(buildId, assetPrefix, initialPage) {\n    _classCallCheck(this, PageLoader);\n\n    this.initialPage = void 0;\n    this.buildId = void 0;\n    this.assetPrefix = void 0;\n    this.pageCache = void 0;\n    this.pageRegisterEvents = void 0;\n    this.loadingRoutes = void 0;\n    this.promisedBuildManifest = void 0;\n    this.promisedSsgManifest = void 0;\n    this.promisedDevPagesManifest = void 0;\n    this.initialPage = initialPage;\n    this.buildId = buildId;\n    this.assetPrefix = assetPrefix;\n    this.pageCache = {};\n    this.pageRegisterEvents = (0, _mitt[\"default\"])();\n    this.loadingRoutes = {\n      // By default these 2 pages are being loaded in the initial html\n      '/_app': true\n    }; // TODO: get rid of this limitation for rendering the error page\n\n    if (initialPage !== '/_error') {\n      this.loadingRoutes[initialPage] = true;\n    }\n\n    this.promisedBuildManifest = new Promise(function (resolve) {\n      if (window.__BUILD_MANIFEST) {\n        resolve(window.__BUILD_MANIFEST);\n      } else {\n        ;\n\n        window.__BUILD_MANIFEST_CB = function () {\n          resolve(window.__BUILD_MANIFEST);\n        };\n      }\n    });\n    /** @type {Promise<Set<string>>} */\n\n    this.promisedSsgManifest = new Promise(function (resolve) {\n      if (window.__SSG_MANIFEST) {\n        resolve(window.__SSG_MANIFEST);\n      } else {\n        ;\n\n        window.__SSG_MANIFEST_CB = function () {\n          resolve(window.__SSG_MANIFEST);\n        };\n      }\n    });\n  }\n\n  _createClass(PageLoader, [{\n    key: \"getPageList\",\n    value: function getPageList() {\n      if (false) {\n        return this.promisedBuildManifest.then(function (buildManifest) {\n          return buildManifest.sortedPages;\n        });\n      } else {\n        if (window.__DEV_PAGES_MANIFEST) {\n          return window.__DEV_PAGES_MANIFEST.pages;\n        } else {\n          if (!this.promisedDevPagesManifest) {\n            this.promisedDevPagesManifest = fetch(\"\".concat(this.assetPrefix, \"/_next/static/development/_devPagesManifest.json\")).then(function (res) {\n              return res.json();\n            }).then(function (manifest) {\n              ;\n              window.__DEV_PAGES_MANIFEST = manifest;\n              return manifest.pages;\n            })[\"catch\"](function (err) {\n              console.log(\"Failed to fetch devPagesManifest\", err);\n            });\n          }\n\n          return this.promisedDevPagesManifest;\n        }\n      }\n    } // Returns a promise for the dependencies for a particular route\n\n  }, {\n    key: \"getDependencies\",\n    value: function getDependencies(route) {\n      var _this = this;\n\n      return this.promisedBuildManifest.then(function (m) {\n        return m[route] ? m[route].map(function (url) {\n          return \"\".concat(_this.assetPrefix, \"/_next/\").concat(encodeURI(url));\n        }) : Promise.reject(pageLoadError(route));\n      });\n    }\n    /**\n    * @param {string} href the route href (file-system path)\n    * @param {string} asPath the URL as shown in browser (virtual path); used for dynamic routes\n    */\n\n  }, {\n    key: \"getDataHref\",\n    value: function getDataHref(href, asPath, ssg) {\n      var _this2 = this;\n\n      var _ref = (0, _parseRelativeUrl.parseRelativeUrl)(href),\n          hrefPathname = _ref.pathname,\n          searchParams = _ref.searchParams,\n          search = _ref.search;\n\n      var query = (0, _querystring.searchParamsToUrlQuery)(searchParams);\n\n      var _ref2 = (0, _parseRelativeUrl.parseRelativeUrl)(asPath),\n          asPathname = _ref2.pathname;\n\n      var route = normalizeRoute(hrefPathname);\n\n      var getHrefForSlug = function getHrefForSlug(path) {\n        var dataRoute = (0, _getAssetPathFromRoute[\"default\"])(path, '.json');\n        return (0, _router.addBasePath)(\"/_next/data/\".concat(_this2.buildId).concat(dataRoute).concat(ssg ? '' : search));\n      };\n\n      var isDynamic = (0, _isDynamic.isDynamicRoute)(route),\n          interpolatedRoute;\n\n      if (isDynamic) {\n        var dynamicRegex = (0, _routeRegex.getRouteRegex)(route);\n        var dynamicGroups = dynamicRegex.groups;\n        var dynamicMatches = // Try to match the dynamic route against the asPath\n        (0, _routeMatcher.getRouteMatcher)(dynamicRegex)(asPathname) || // Fall back to reading the values from the href\n        // TODO: should this take priority; also need to change in the router.\n        query;\n        interpolatedRoute = route;\n\n        if (!Object.keys(dynamicGroups).every(function (param) {\n          var value = dynamicMatches[param] || '';\n          var _dynamicGroups$param = dynamicGroups[param],\n              repeat = _dynamicGroups$param.repeat,\n              optional = _dynamicGroups$param.optional; // support single-level catch-all\n          // TODO: more robust handling for user-error (passing `/`)\n\n          var replaced = \"[\".concat(repeat ? '...' : '').concat(param, \"]\");\n\n          if (optional) {\n            replaced = \"\".concat(!value ? '/' : '', \"[\").concat(replaced, \"]\");\n          }\n\n          if (repeat && !Array.isArray(value)) value = [value];\n          return (optional || param in dynamicMatches) && ( // Interpolate group into data URL if present\n          interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(_escapePathDelimiters[\"default\"]).join('/') : (0, _escapePathDelimiters[\"default\"])(value)) || '/');\n        })) {\n          interpolatedRoute = ''; // did not satisfy all requirements\n          // n.b. We ignore this error because we handle warning for this case in\n          // development in the `<Link>` component directly.\n        }\n      }\n\n      return isDynamic ? interpolatedRoute && getHrefForSlug(interpolatedRoute) : getHrefForSlug(route);\n    }\n    /**\n    * @param {string} href the route href (file-system path)\n    * @param {string} asPath the URL as shown in browser (virtual path); used for dynamic routes\n    */\n\n  }, {\n    key: \"prefetchData\",\n    value: function prefetchData(href, asPath) {\n      var _this3 = this;\n\n      var _ref3 = (0, _parseRelativeUrl.parseRelativeUrl)(href),\n          hrefPathname = _ref3.pathname;\n\n      var route = normalizeRoute(hrefPathname);\n      return this.promisedSsgManifest.then(function (s, _dataHref) {\n        return (// Check if the route requires a data file\n          s.has(route) && ( // Try to generate data href, noop when falsy\n          _dataHref = _this3.getDataHref(href, asPath, true)) && // noop when data has already been prefetched (dedupe)\n          !document.querySelector(\"link[rel=\\\"\".concat(relPrefetch, \"\\\"][href^=\\\"\").concat(_dataHref, \"\\\"]\")) && // Inject the `<link rel=prefetch>` tag for above computed `href`.\n          appendLink(_dataHref, relPrefetch, 'fetch')[\"catch\"](function () {\n            /* ignore prefetch error */\n          })\n        );\n      });\n    }\n  }, {\n    key: \"loadPage\",\n    value: function loadPage(route) {\n      var _this4 = this;\n\n      route = normalizeRoute(route);\n      return new Promise(function (resolve, reject) {\n        // If there's a cached version of the page, let's use it.\n        var cachedPage = _this4.pageCache[route];\n\n        if (cachedPage) {\n          if ('error' in cachedPage) {\n            reject(cachedPage.error);\n          } else {\n            resolve(cachedPage);\n          }\n\n          return;\n        }\n\n        var fire = function fire(pageToCache) {\n          _this4.pageRegisterEvents.off(route, fire);\n\n          delete _this4.loadingRoutes[route];\n\n          if ('error' in pageToCache) {\n            reject(pageToCache.error);\n          } else {\n            resolve(pageToCache);\n          }\n        }; // Register a listener to get the page\n\n\n        _this4.pageRegisterEvents.on(route, fire);\n\n        if (!_this4.loadingRoutes[route]) {\n          _this4.loadingRoutes[route] = true;\n\n          if (false) {\n            _this4.getDependencies(route).then(function (deps) {\n              var pending = [];\n              deps.forEach(function (d) {\n                if (d.endsWith('.js') && !document.querySelector(\"script[src^=\\\"\".concat(d, \"\\\"]\"))) {\n                  pending.push(loadScript(d));\n                } // Prefetch CSS as it'll be needed when the page JavaScript\n                // evaluates. This will only trigger if explicit prefetching is\n                // disabled for a <Link>... prefetching in this case is desirable\n                // because we *know* it's going to be used very soon (page was\n                // loaded).\n\n\n                if (d.endsWith('.css') && !document.querySelector(\"link[rel=\\\"\".concat(relPreload, \"\\\"][href^=\\\"\").concat(d, \"\\\"]\"))) {\n                  // This is not pushed into `pending` because we don't need to\n                  // wait for these to resolve. To prevent an unhandled\n                  // rejection, we swallow the error which is handled later in\n                  // the rendering cycle (this is just a preload optimization).\n                  appendLink(d, relPreload, relPreloadStyle)[\"catch\"](function () {\n                    /* ignore preload error */\n                  });\n                }\n              });\n              return Promise.all(pending);\n            })[\"catch\"](function (err) {\n              // Mark the page as failed to load if any of its required scripts\n              // fail to load:\n              _this4.pageCache[route] = {\n                error: err\n              };\n              fire({\n                error: err\n              });\n            });\n          } else {\n            // Development only. In production the page file is part of the build manifest\n            route = normalizeRoute(route);\n            var scriptRoute = (0, _getAssetPathFromRoute[\"default\"])(route, '.js');\n            var url = \"\".concat(_this4.assetPrefix, \"/_next/static/chunks/pages\").concat(encodeURI(scriptRoute));\n            loadScript(url)[\"catch\"](function (err) {\n              // Mark the page as failed to load if its script fails to load:\n              _this4.pageCache[route] = {\n                error: err\n              };\n              fire({\n                error: err\n              });\n            });\n          }\n        }\n      });\n    } // This method if called by the route code.\n\n  }, {\n    key: \"registerPage\",\n    value: function registerPage(route, regFn) {\n      var _this5 = this;\n\n      var register = function register(styleSheets) {\n        try {\n          var mod = regFn();\n          var pageData = {\n            page: mod[\"default\"] || mod,\n            mod: mod,\n            styleSheets: styleSheets\n          };\n          _this5.pageCache[route] = pageData;\n\n          _this5.pageRegisterEvents.emit(route, pageData);\n        } catch (error) {\n          _this5.pageCache[route] = {\n            error: error\n          };\n\n          _this5.pageRegisterEvents.emit(route, {\n            error: error\n          });\n        }\n      };\n\n      if (true) {\n        // Wait for webpack to become idle if it's not.\n        // More info: https://github.com/vercel/next.js/pull/1511\n        if (module.hot && module.hot.status() !== 'idle') {\n          console.log(\"Waiting for webpack to become \\\"idle\\\" to initialize the page: \\\"\".concat(route, \"\\\"\"));\n\n          var check = function check(status) {\n            if (status === 'idle') {\n              ;\n              module.hot.removeStatusHandler(check);\n              register(\n              /* css is handled via style-loader in development */\n              []);\n            }\n          };\n\n          module.hot.status(check);\n          return;\n        }\n      }\n\n      function fetchStyleSheet(href) {\n        return fetch(href).then(function (res) {\n          if (!res.ok) throw pageLoadError(href);\n          return res.text().then(function (text) {\n            return {\n              href: href,\n              text: text\n            };\n          });\n        });\n      }\n\n      var isInitialLoad = route === this.initialPage;\n      var promisedDeps = // Shared styles will already be on the page:\n      route === '/_app' || // We use `style-loader` in development:\n      true ? Promise.resolve([]) : // Tests that this does not block hydration:\n      // test/integration/css-fixtures/hydrate-without-deps/\n      (isInitialLoad ? Promise.resolve(looseToArray(document.querySelectorAll('link[data-n-p]')).map(function (e) {\n        return e.getAttribute('href');\n      })) : this.getDependencies(route).then(function (deps) {\n        return deps.filter(function (d) {\n          return d.endsWith('.css');\n        });\n      })).then(function (cssFiles) {\n        return (// These files should've already been fetched by now, so this\n          // should resolve instantly.\n          Promise.all(cssFiles.map(function (d) {\n            return fetchStyleSheet(d);\n          }))[\"catch\"](function (err) {\n            if (isInitialLoad) return getInitialStylesheets();\n            throw err;\n          })\n        );\n      });\n      promisedDeps.then(function (deps) {\n        return register(deps);\n      }, function (error) {\n        _this5.pageCache[route] = {\n          error: error\n        };\n\n        _this5.pageRegisterEvents.emit(route, {\n          error: error\n        });\n      });\n    }\n    /**\n    * @param {string} route\n    * @param {boolean} [isDependency]\n    */\n\n  }, {\n    key: \"prefetch\",\n    value: function prefetch(route, isDependency) {\n      var _this6 = this;\n\n      // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118\n      // License: Apache 2.0\n      var cn;\n\n      if (cn = navigator.connection) {\n        // Don't prefetch if using 2G or if Save-Data is enabled.\n        if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();\n      }\n      /** @type {string} */\n\n\n      var url;\n\n      if (isDependency) {\n        url = route;\n      } else {\n        if (true) {\n          route = normalizeRoute(route);\n          var ext = process.env.__NEXT_MODERN_BUILD && hasNoModule ? '.module.js' : '.js';\n          var scriptRoute = (0, _getAssetPathFromRoute[\"default\"])(route, ext);\n          url = \"\".concat(this.assetPrefix, \"/_next/static/\").concat(encodeURIComponent(this.buildId), \"/pages\").concat(encodeURI(scriptRoute));\n        }\n      }\n\n      return Promise.all(document.querySelector(\"link[rel=\\\"\".concat(relPrefetch, \"\\\"][href^=\\\"\").concat(url, \"\\\"]\")) ? [] : [url && appendLink(url, relPrefetch, url.endsWith('.css') ? relPreloadStyle : 'script'), false && !isDependency && this.getDependencies(route).then(function (urls) {\n        return Promise.all(urls.map(function (dependencyUrl) {\n          return _this6.prefetch(dependencyUrl, true);\n        }));\n      })]).then( // do not return any data\n      function () {}, // swallow prefetch errors\n      function () {});\n    }\n  }]);\n\n  return PageLoader;\n}();\n\nexports[\"default\"] = PageLoader;","map":{"version":3,"sources":["../../client/page-loader.ts"],"names":["relPreload","hasRel","hasNoModule","document","createElement","normalizeRoute","route","link","initialPage","loadingRoutes","promisedBuildManifest","Promise","__BUILD_MANIFEST","__BUILD_MANIFEST_CB","resolve","promisedSsgManifest","window","__SSG_MANIFEST","__SSG_MANIFEST_CB","getDependencies","m","assetPrefix","getDataHref","asPath","pathname","searchParams","href","asPathname","getHrefForSlug","dataRoute","search","interpolatedRoute","dynamicRegex","dynamicGroups","dynamicMatches","replaced","repeat","isDynamic","prefetchData","s","appendLink","relPrefetch","cachedPage","pageRegisterEvents","relPreloadStyle","pageCache","fire","registerPage","module","status","console","removeStatusHandler","process","NODE_ENV","isInitialLoad","looseToArray","then","deps","d","endsWith","fetchStyleSheet","prefetch"],"mappings":"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","sourcesContent":["import { ComponentType } from 'react'\nimport type { ClientSsgManifest } from '../build'\nimport type { ClientBuildManifest } from '../build/webpack/plugins/build-manifest-plugin'\nimport mitt from '../next-server/lib/mitt'\nimport type { MittEmitter } from '../next-server/lib/mitt'\nimport { addBasePath, markLoadingError } from '../next-server/lib/router/router'\nimport escapePathDelimiters from '../next-server/lib/router/utils/escape-path-delimiters'\nimport getAssetPathFromRoute from '../next-server/lib/router/utils/get-asset-path-from-route'\nimport { isDynamicRoute } from '../next-server/lib/router/utils/is-dynamic'\nimport { parseRelativeUrl } from '../next-server/lib/router/utils/parse-relative-url'\nimport { searchParamsToUrlQuery } from '../next-server/lib/router/utils/querystring'\nimport { getRouteMatcher } from '../next-server/lib/router/utils/route-matcher'\nimport { getRouteRegex } from '../next-server/lib/router/utils/route-regex'\n\nexport const looseToArray = <T extends {}>(input: any): T[] =>\n  [].slice.call(input)\n\nfunction getInitialStylesheets(): StyleSheetTuple[] {\n  return looseToArray<CSSStyleSheet>(document.styleSheets)\n    .filter(\n      (el: CSSStyleSheet) =>\n        el.ownerNode &&\n        (el.ownerNode as Element).tagName === 'LINK' &&\n        (el.ownerNode as Element).hasAttribute('data-n-p')\n    )\n    .map((sheet) => ({\n      href: (sheet.ownerNode as Element).getAttribute('href')!,\n      text: looseToArray<CSSRule>(sheet.cssRules)\n        .map((r) => r.cssText)\n        .join(''),\n    }))\n}\n\nfunction hasRel(rel: string, link?: HTMLLinkElement) {\n  try {\n    link = document.createElement('link')\n    return link.relList.supports(rel)\n  } catch {}\n}\n\nfunction pageLoadError(route: string) {\n  return markLoadingError(new Error(`Error loading ${route}`))\n}\n\nconst relPrefetch =\n  hasRel('preload') && !hasRel('prefetch')\n    ? // https://caniuse.com/#feat=link-rel-preload\n      // macOS and iOS (Safari does not support prefetch)\n      'preload'\n    : // https://caniuse.com/#feat=link-rel-prefetch\n      // IE 11, Edge 12+, nearly all evergreen\n      'prefetch'\n\nconst relPreload = hasRel('preload') ? 'preload' : relPrefetch\nconst relPreloadStyle = 'fetch'\n\nconst hasNoModule = 'noModule' in document.createElement('script')\n\nfunction normalizeRoute(route: string) {\n  if (route[0] !== '/') {\n    throw new Error(`Route name should start with a \"/\", got \"${route}\"`)\n  }\n\n  if (route === '/') return route\n  return route.replace(/\\/$/, '')\n}\n\nfunction appendLink(\n  href: string,\n  rel: string,\n  as?: string,\n  link?: HTMLLinkElement\n): Promise<any> {\n  return new Promise((res, rej) => {\n    link = document.createElement('link')\n\n    // The order of property assignment here is intentional:\n    if (as) link!.as = as\n    link!.rel = rel\n    link!.crossOrigin = process.env.__NEXT_CROSS_ORIGIN!\n    link!.onload = res\n    link!.onerror = rej\n\n    // `href` should always be last:\n    link!.href = href\n\n    document.head.appendChild(link)\n  })\n}\n\nfunction loadScript(url: string): Promise<any> {\n  return new Promise((res, rej) => {\n    const script = document.createElement('script')\n    if (process.env.__NEXT_MODERN_BUILD && hasNoModule) {\n      script.type = 'module'\n    }\n    script.crossOrigin = process.env.__NEXT_CROSS_ORIGIN!\n    script.src = url\n    script.onload = res\n    script.onerror = () => rej(pageLoadError(url))\n    document.body.appendChild(script)\n  })\n}\n\nexport type StyleSheetTuple = { href: string; text: string }\nexport type GoodPageCache = {\n  page: ComponentType\n  mod: any\n  styleSheets: StyleSheetTuple[]\n}\nexport type PageCacheEntry = { error: any } | GoodPageCache\n\nexport default class PageLoader {\n  private initialPage: string\n  private buildId: string\n  private assetPrefix: string\n  private pageCache: Record<string, PageCacheEntry>\n  private pageRegisterEvents: MittEmitter\n  private loadingRoutes: Record<string, boolean>\n  private promisedBuildManifest?: Promise<ClientBuildManifest>\n  private promisedSsgManifest?: Promise<ClientSsgManifest>\n  private promisedDevPagesManifest?: Promise<any>\n\n  constructor(buildId: string, assetPrefix: string, initialPage: string) {\n    this.initialPage = initialPage\n\n    this.buildId = buildId\n    this.assetPrefix = assetPrefix\n\n    this.pageCache = {}\n    this.pageRegisterEvents = mitt()\n    this.loadingRoutes = {\n      // By default these 2 pages are being loaded in the initial html\n      '/_app': true,\n    }\n\n    // TODO: get rid of this limitation for rendering the error page\n    if (initialPage !== '/_error') {\n      this.loadingRoutes[initialPage] = true\n    }\n\n    this.promisedBuildManifest = new Promise((resolve) => {\n      if ((window as any).__BUILD_MANIFEST) {\n        resolve((window as any).__BUILD_MANIFEST)\n      } else {\n        ;(window as any).__BUILD_MANIFEST_CB = () => {\n          resolve((window as any).__BUILD_MANIFEST)\n        }\n      }\n    })\n\n    /** @type {Promise<Set<string>>} */\n    this.promisedSsgManifest = new Promise((resolve) => {\n      if ((window as any).__SSG_MANIFEST) {\n        resolve((window as any).__SSG_MANIFEST)\n      } else {\n        ;(window as any).__SSG_MANIFEST_CB = () => {\n          resolve((window as any).__SSG_MANIFEST)\n        }\n      }\n    })\n  }\n\n  getPageList() {\n    if (process.env.NODE_ENV === 'production') {\n      return this.promisedBuildManifest!.then(\n        (buildManifest) => buildManifest.sortedPages\n      )\n    } else {\n      if ((window as any).__DEV_PAGES_MANIFEST) {\n        return (window as any).__DEV_PAGES_MANIFEST.pages\n      } else {\n        if (!this.promisedDevPagesManifest) {\n          this.promisedDevPagesManifest = fetch(\n            `${this.assetPrefix}/_next/static/development/_devPagesManifest.json`\n          )\n            .then((res) => res.json())\n            .then((manifest) => {\n              ;(window as any).__DEV_PAGES_MANIFEST = manifest\n              return manifest.pages\n            })\n            .catch((err) => {\n              console.log(`Failed to fetch devPagesManifest`, err)\n            })\n        }\n        return this.promisedDevPagesManifest\n      }\n    }\n  }\n\n  // Returns a promise for the dependencies for a particular route\n  private getDependencies(route: string): Promise<string[]> {\n    return this.promisedBuildManifest!.then((m) => {\n      return m[route]\n        ? m[route].map((url) => `${this.assetPrefix}/_next/${encodeURI(url)}`)\n        : Promise.reject(pageLoadError(route))\n    })\n  }\n\n  /**\n   * @param {string} href the route href (file-system path)\n   * @param {string} asPath the URL as shown in browser (virtual path); used for dynamic routes\n   */\n  getDataHref(href: string, asPath: string, ssg: boolean) {\n    const { pathname: hrefPathname, searchParams, search } = parseRelativeUrl(\n      href\n    )\n    const query = searchParamsToUrlQuery(searchParams)\n    const { pathname: asPathname } = parseRelativeUrl(asPath)\n    const route = normalizeRoute(hrefPathname)\n\n    const getHrefForSlug = (path: string) => {\n      const dataRoute = getAssetPathFromRoute(path, '.json')\n      return addBasePath(\n        `/_next/data/${this.buildId}${dataRoute}${ssg ? '' : search}`\n      )\n    }\n\n    let isDynamic: boolean = isDynamicRoute(route),\n      interpolatedRoute: string | undefined\n    if (isDynamic) {\n      const dynamicRegex = getRouteRegex(route)\n      const dynamicGroups = dynamicRegex.groups\n      const dynamicMatches =\n        // Try to match the dynamic route against the asPath\n        getRouteMatcher(dynamicRegex)(asPathname) ||\n        // Fall back to reading the values from the href\n        // TODO: should this take priority; also need to change in the router.\n        query\n\n      interpolatedRoute = route\n      if (\n        !Object.keys(dynamicGroups).every((param) => {\n          let value = dynamicMatches[param] || ''\n          const { repeat, optional } = dynamicGroups[param]\n\n          // support single-level catch-all\n          // TODO: more robust handling for user-error (passing `/`)\n          let replaced = `[${repeat ? '...' : ''}${param}]`\n          if (optional) {\n            replaced = `${!value ? '/' : ''}[${replaced}]`\n          }\n          if (repeat && !Array.isArray(value)) value = [value]\n\n          return (\n            (optional || param in dynamicMatches) &&\n            // Interpolate group into data URL if present\n            (interpolatedRoute =\n              interpolatedRoute!.replace(\n                replaced,\n                repeat\n                  ? (value as string[]).map(escapePathDelimiters).join('/')\n                  : escapePathDelimiters(value as string)\n              ) || '/')\n          )\n        })\n      ) {\n        interpolatedRoute = '' // did not satisfy all requirements\n\n        // n.b. We ignore this error because we handle warning for this case in\n        // development in the `<Link>` component directly.\n      }\n    }\n\n    return isDynamic\n      ? interpolatedRoute && getHrefForSlug(interpolatedRoute)\n      : getHrefForSlug(route)\n  }\n\n  /**\n   * @param {string} href the route href (file-system path)\n   * @param {string} asPath the URL as shown in browser (virtual path); used for dynamic routes\n   */\n  prefetchData(href: string, asPath: string) {\n    const { pathname: hrefPathname } = parseRelativeUrl(href)\n    const route = normalizeRoute(hrefPathname)\n    return this.promisedSsgManifest!.then(\n      (s: ClientSsgManifest, _dataHref?: string) =>\n        // Check if the route requires a data file\n        s.has(route) &&\n        // Try to generate data href, noop when falsy\n        (_dataHref = this.getDataHref(href, asPath, true)) &&\n        // noop when data has already been prefetched (dedupe)\n        !document.querySelector(\n          `link[rel=\"${relPrefetch}\"][href^=\"${_dataHref}\"]`\n        ) &&\n        // Inject the `<link rel=prefetch>` tag for above computed `href`.\n        appendLink(_dataHref, relPrefetch, 'fetch').catch(() => {\n          /* ignore prefetch error */\n        })\n    )\n  }\n\n  loadPage(route: string): Promise<GoodPageCache> {\n    route = normalizeRoute(route)\n\n    return new Promise<GoodPageCache>((resolve, reject) => {\n      // If there's a cached version of the page, let's use it.\n      const cachedPage = this.pageCache[route]\n      if (cachedPage) {\n        if ('error' in cachedPage) {\n          reject(cachedPage.error)\n        } else {\n          resolve(cachedPage)\n        }\n        return\n      }\n\n      const fire = (pageToCache: PageCacheEntry) => {\n        this.pageRegisterEvents.off(route, fire)\n        delete this.loadingRoutes[route]\n\n        if ('error' in pageToCache) {\n          reject(pageToCache.error)\n        } else {\n          resolve(pageToCache)\n        }\n      }\n\n      // Register a listener to get the page\n      this.pageRegisterEvents.on(route, fire)\n\n      if (!this.loadingRoutes[route]) {\n        this.loadingRoutes[route] = true\n        if (process.env.NODE_ENV === 'production') {\n          this.getDependencies(route)\n            .then((deps) => {\n              const pending: Promise<any>[] = []\n              deps.forEach((d) => {\n                if (\n                  d.endsWith('.js') &&\n                  !document.querySelector(`script[src^=\"${d}\"]`)\n                ) {\n                  pending.push(loadScript(d))\n                }\n\n                // Prefetch CSS as it'll be needed when the page JavaScript\n                // evaluates. This will only trigger if explicit prefetching is\n                // disabled for a <Link>... prefetching in this case is desirable\n                // because we *know* it's going to be used very soon (page was\n                // loaded).\n                if (\n                  d.endsWith('.css') &&\n                  !document.querySelector(\n                    `link[rel=\"${relPreload}\"][href^=\"${d}\"]`\n                  )\n                ) {\n                  // This is not pushed into `pending` because we don't need to\n                  // wait for these to resolve. To prevent an unhandled\n                  // rejection, we swallow the error which is handled later in\n                  // the rendering cycle (this is just a preload optimization).\n                  appendLink(d, relPreload, relPreloadStyle).catch(() => {\n                    /* ignore preload error */\n                  })\n                }\n              })\n              return Promise.all(pending)\n            })\n            .catch((err) => {\n              // Mark the page as failed to load if any of its required scripts\n              // fail to load:\n              this.pageCache[route] = { error: err }\n              fire({ error: err })\n            })\n        } else {\n          // Development only. In production the page file is part of the build manifest\n          route = normalizeRoute(route)\n          let scriptRoute = getAssetPathFromRoute(route, '.js')\n\n          const url = `${this.assetPrefix}/_next/static/chunks/pages${encodeURI(\n            scriptRoute\n          )}`\n          loadScript(url).catch((err) => {\n            // Mark the page as failed to load if its script fails to load:\n            this.pageCache[route] = { error: err }\n            fire({ error: err })\n          })\n        }\n      }\n    })\n  }\n\n  // This method if called by the route code.\n  registerPage(route: string, regFn: () => any) {\n    const register = (styleSheets: StyleSheetTuple[]) => {\n      try {\n        const mod = regFn()\n        const pageData: PageCacheEntry = {\n          page: mod.default || mod,\n          mod,\n          styleSheets,\n        }\n        this.pageCache[route] = pageData\n        this.pageRegisterEvents.emit(route, pageData)\n      } catch (error) {\n        this.pageCache[route] = { error }\n        this.pageRegisterEvents.emit(route, { error })\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Wait for webpack to become idle if it's not.\n      // More info: https://github.com/vercel/next.js/pull/1511\n      if ((module as any).hot && (module as any).hot.status() !== 'idle') {\n        console.log(\n          `Waiting for webpack to become \"idle\" to initialize the page: \"${route}\"`\n        )\n\n        const check = (status: string) => {\n          if (status === 'idle') {\n            ;(module as any).hot.removeStatusHandler(check)\n            register(\n              /* css is handled via style-loader in development */\n              []\n            )\n          }\n        }\n        ;(module as any).hot.status(check)\n        return\n      }\n    }\n\n    function fetchStyleSheet(href: string): Promise<StyleSheetTuple> {\n      return fetch(href).then((res) => {\n        if (!res.ok) throw pageLoadError(href)\n        return res.text().then((text) => ({ href, text }))\n      })\n    }\n\n    const isInitialLoad = route === this.initialPage\n    const promisedDeps: Promise<StyleSheetTuple[]> =\n      // Shared styles will already be on the page:\n      route === '/_app' ||\n      // We use `style-loader` in development:\n      process.env.NODE_ENV !== 'production'\n        ? Promise.resolve([])\n        : // Tests that this does not block hydration:\n          // test/integration/css-fixtures/hydrate-without-deps/\n          (isInitialLoad\n            ? Promise.resolve(\n                looseToArray<HTMLLinkElement>(\n                  document.querySelectorAll('link[data-n-p]')\n                ).map((e) => e.getAttribute('href')!)\n              )\n            : this.getDependencies(route).then((deps) =>\n                deps.filter((d) => d.endsWith('.css'))\n              )\n          ).then((cssFiles) =>\n            // These files should've already been fetched by now, so this\n            // should resolve instantly.\n            Promise.all(cssFiles.map((d) => fetchStyleSheet(d))).catch(\n              (err) => {\n                if (isInitialLoad) return getInitialStylesheets()\n                throw err\n              }\n            )\n          )\n    promisedDeps.then(\n      (deps) => register(deps),\n      (error) => {\n        this.pageCache[route] = { error }\n        this.pageRegisterEvents.emit(route, { error })\n      }\n    )\n  }\n\n  /**\n   * @param {string} route\n   * @param {boolean} [isDependency]\n   */\n  prefetch(route: string, isDependency?: boolean): Promise<void> {\n    // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118\n    // License: Apache 2.0\n    let cn\n    if ((cn = (navigator as any).connection)) {\n      // Don't prefetch if using 2G or if Save-Data is enabled.\n      if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve()\n    }\n\n    /** @type {string} */\n    let url\n    if (isDependency) {\n      url = route\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        route = normalizeRoute(route)\n\n        const ext =\n          process.env.__NEXT_MODERN_BUILD && hasNoModule ? '.module.js' : '.js'\n        const scriptRoute = getAssetPathFromRoute(route, ext)\n\n        url = `${this.assetPrefix}/_next/static/${encodeURIComponent(\n          this.buildId\n        )}/pages${encodeURI(scriptRoute)}`\n      }\n    }\n\n    return Promise.all(\n      document.querySelector(`link[rel=\"${relPrefetch}\"][href^=\"${url}\"]`)\n        ? []\n        : [\n            url &&\n              appendLink(\n                url,\n                relPrefetch,\n                url.endsWith('.css') ? relPreloadStyle : 'script'\n              ),\n            process.env.NODE_ENV === 'production' &&\n              !isDependency &&\n              this.getDependencies(route).then((urls) =>\n                Promise.all(\n                  urls.map((dependencyUrl) =>\n                    this.prefetch(dependencyUrl, true)\n                  )\n                )\n              ),\n          ]\n    ).then(\n      // do not return any data\n      () => {},\n      // swallow prefetch errors\n      () => {}\n    )\n  }\n}\n"]},"metadata":{},"sourceType":"script"}