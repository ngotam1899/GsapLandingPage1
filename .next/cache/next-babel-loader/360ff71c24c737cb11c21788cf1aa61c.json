{"ast":null,"code":"/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\"use strict\";\n\nexports.__esModule = true;\nexports.getRouteRegex = getRouteRegex; // this isn't importing the escape-string-regex module\n// to reduce bytes\n\nfunction escapeRegex(str) {\n  return str.replace(/[|\\\\{}()[\\]^$+*?.-]/g, '\\\\$&');\n}\n\nfunction parseParameter(param) {\n  var optional = param.startsWith('[') && param.endsWith(']');\n\n  if (optional) {\n    param = param.slice(1, -1);\n  }\n\n  var repeat = param.startsWith('...');\n\n  if (repeat) {\n    param = param.slice(3);\n  }\n\n  return {\n    key: param,\n    repeat: repeat,\n    optional: optional\n  };\n}\n\nfunction getRouteRegex(normalizedRoute) {\n  var segments = (normalizedRoute.replace(/\\/$/, '') || '/').slice(1).split('/');\n  var groups = {};\n  var groupIndex = 1;\n  var parameterizedRoute = segments.map(function (segment) {\n    if (segment.startsWith('[') && segment.endsWith(']')) {\n      var _parseParameter = parseParameter(segment.slice(1, -1)),\n          key = _parseParameter.key,\n          optional = _parseParameter.optional,\n          repeat = _parseParameter.repeat;\n\n      groups[key] = {\n        pos: groupIndex++,\n        repeat: repeat,\n        optional: optional\n      };\n      return repeat ? optional ? '(?:/(.+?))?' : '/(.+?)' : '/([^/]+?)';\n    } else {\n      return \"/\".concat(escapeRegex(segment));\n    }\n  }).join(''); // dead code eliminate for browser since it's only needed\n  // while generating routes-manifest\n\n  if (false) {\n    var routeKeyCharCode = 97;\n    var routeKeyCharLength = 1; // builds a minimal routeKey using only a-z and minimal number of characters\n\n    var getSafeRouteKey = function getSafeRouteKey() {\n      var routeKey = '';\n\n      for (var i = 0; i < routeKeyCharLength; i++) {\n        routeKey += String.fromCharCode(routeKeyCharCode);\n        routeKeyCharCode++;\n\n        if (routeKeyCharCode > 122) {\n          routeKeyCharLength++;\n          routeKeyCharCode = 97;\n        }\n      }\n\n      return routeKey;\n    };\n\n    var routeKeys = {};\n    var namedParameterizedRoute = segments.map(function (segment) {\n      if (segment.startsWith('[') && segment.endsWith(']')) {\n        var _parseParameter2 = parseParameter(segment.slice(1, -1)),\n            key = _parseParameter2.key,\n            optional = _parseParameter2.optional,\n            repeat = _parseParameter2.repeat; // replace any non-word characters since they can break\n        // the named regex\n\n\n        var cleanedKey = key.replace(/\\W/g, '');\n        var invalidKey = false; // check if the key is still invalid and fallback to using a known\n        // safe key\n\n        if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n          invalidKey = true;\n        }\n\n        if (!isNaN(parseInt(cleanedKey.substr(0, 1)))) {\n          invalidKey = true;\n        }\n\n        if (invalidKey) {\n          cleanedKey = getSafeRouteKey();\n        }\n\n        routeKeys[cleanedKey] = key;\n        return repeat ? optional ? \"(?:/(?<\".concat(cleanedKey, \">.+?))?\") : \"/(?<\".concat(cleanedKey, \">.+?)\") : \"/(?<\".concat(cleanedKey, \">[^/]+?)\");\n      } else {\n        return \"/\".concat(escapeRegex(segment));\n      }\n    }).join('');\n    return {\n      re: new RegExp(\"^\".concat(parameterizedRoute, \"(?:/)?$\")),\n      groups: groups,\n      routeKeys: routeKeys,\n      namedRegex: \"^\".concat(namedParameterizedRoute, \"(?:/)?$\")\n    };\n  }\n\n  return {\n    re: new RegExp(\"^\".concat(parameterizedRoute, \"(?:/)?$\")),\n    groups: groups\n  };\n}","map":{"version":3,"sources":["../../../../../next-server/lib/router/utils/route-regex.ts"],"names":["escapeRegex","routeKeyCharCode","routeKeyCharLength","segments","cleanedKey","length","invalidKey","parseInt","substr","getSafeRouteKey","routeKeys","repeat","optional","segment","parameterizedRoute","groups"],"mappings":"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","sourcesContent":["interface Group {\n  pos: number\n  repeat: boolean\n  optional: boolean\n}\n\n// this isn't importing the escape-string-regex module\n// to reduce bytes\nfunction escapeRegex(str: string) {\n  return str.replace(/[|\\\\{}()[\\]^$+*?.-]/g, '\\\\$&')\n}\n\nfunction parseParameter(param: string) {\n  const optional = param.startsWith('[') && param.endsWith(']')\n  if (optional) {\n    param = param.slice(1, -1)\n  }\n  const repeat = param.startsWith('...')\n  if (repeat) {\n    param = param.slice(3)\n  }\n  return { key: param, repeat, optional }\n}\n\nexport function getRouteRegex(\n  normalizedRoute: string\n): {\n  re: RegExp\n  namedRegex?: string\n  routeKeys?: { [named: string]: string }\n  groups: { [groupName: string]: Group }\n} {\n  const segments = (normalizedRoute.replace(/\\/$/, '') || '/')\n    .slice(1)\n    .split('/')\n\n  const groups: { [groupName: string]: Group } = {}\n  let groupIndex = 1\n  const parameterizedRoute = segments\n    .map((segment) => {\n      if (segment.startsWith('[') && segment.endsWith(']')) {\n        const { key, optional, repeat } = parseParameter(segment.slice(1, -1))\n        groups[key] = { pos: groupIndex++, repeat, optional }\n        return repeat ? (optional ? '(?:/(.+?))?' : '/(.+?)') : '/([^/]+?)'\n      } else {\n        return `/${escapeRegex(segment)}`\n      }\n    })\n    .join('')\n\n  // dead code eliminate for browser since it's only needed\n  // while generating routes-manifest\n  if (typeof window === 'undefined') {\n    let routeKeyCharCode = 97\n    let routeKeyCharLength = 1\n\n    // builds a minimal routeKey using only a-z and minimal number of characters\n    const getSafeRouteKey = () => {\n      let routeKey = ''\n\n      for (let i = 0; i < routeKeyCharLength; i++) {\n        routeKey += String.fromCharCode(routeKeyCharCode)\n        routeKeyCharCode++\n\n        if (routeKeyCharCode > 122) {\n          routeKeyCharLength++\n          routeKeyCharCode = 97\n        }\n      }\n      return routeKey\n    }\n\n    const routeKeys: { [named: string]: string } = {}\n\n    let namedParameterizedRoute = segments\n      .map((segment) => {\n        if (segment.startsWith('[') && segment.endsWith(']')) {\n          const { key, optional, repeat } = parseParameter(segment.slice(1, -1))\n          // replace any non-word characters since they can break\n          // the named regex\n          let cleanedKey = key.replace(/\\W/g, '')\n          let invalidKey = false\n\n          // check if the key is still invalid and fallback to using a known\n          // safe key\n          if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n            invalidKey = true\n          }\n          if (!isNaN(parseInt(cleanedKey.substr(0, 1)))) {\n            invalidKey = true\n          }\n\n          if (invalidKey) {\n            cleanedKey = getSafeRouteKey()\n          }\n\n          routeKeys[cleanedKey] = key\n          return repeat\n            ? optional\n              ? `(?:/(?<${cleanedKey}>.+?))?`\n              : `/(?<${cleanedKey}>.+?)`\n            : `/(?<${cleanedKey}>[^/]+?)`\n        } else {\n          return `/${escapeRegex(segment)}`\n        }\n      })\n      .join('')\n\n    return {\n      re: new RegExp(`^${parameterizedRoute}(?:/)?$`),\n      groups,\n      routeKeys,\n      namedRegex: `^${namedParameterizedRoute}(?:/)?$`,\n    }\n  }\n\n  return {\n    re: new RegExp(`^${parameterizedRoute}(?:/)?$`),\n    groups,\n  }\n}\n"]},"metadata":{},"sourceType":"script"}