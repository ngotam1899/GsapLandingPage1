{"ast":null,"code":"var _construct = require(\"@babel/runtime/helpers/construct\");\n\nvar _s = $RefreshSig$();\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports.useRouter = useRouter;\nexports.makePublicRouterInstance = makePublicRouterInstance;\nexports.createRouter = exports.withRouter = exports[\"default\"] = void 0;\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _router2 = _interopRequireWildcard(require(\"../next-server/lib/router/router\"));\n\nexports.Router = _router2[\"default\"];\nexports.NextRouter = _router2.NextRouter;\n\nvar _routerContext = require(\"../next-server/lib/router-context\");\n\nvar _withRouter = _interopRequireDefault(require(\"./with-router\"));\n\nexports.withRouter = _withRouter[\"default\"];\n/* global window */\n\nvar singletonRouter = {\n  router: null,\n  // holds the actual router instance\n  readyCallbacks: [],\n  ready: function ready(cb) {\n    if (this.router) return cb();\n\n    if (true) {\n      this.readyCallbacks.push(cb);\n    }\n  }\n}; // Create public properties and methods of the router in the singletonRouter\n\nvar urlPropertyFields = ['pathname', 'route', 'query', 'asPath', 'components', 'isFallback', 'basePath'];\nvar routerEvents = ['routeChangeStart', 'beforeHistoryChange', 'routeChangeComplete', 'routeChangeError', 'hashChangeStart', 'hashChangeComplete'];\nvar coreMethodFields = ['push', 'replace', 'reload', 'back', 'prefetch', 'beforePopState']; // Events is a static property on the router, the router doesn't have to be initialized to use it\n\nObject.defineProperty(singletonRouter, 'events', {\n  get: function get() {\n    return _router2[\"default\"].events;\n  }\n});\nurlPropertyFields.forEach(function (field) {\n  // Here we need to use Object.defineProperty because, we need to return\n  // the property assigned to the actual router\n  // The value might get changed as we change routes and this is the\n  // proper way to access it\n  Object.defineProperty(singletonRouter, field, {\n    get: function get() {\n      var router = getRouter();\n      return router[field];\n    }\n  });\n});\ncoreMethodFields.forEach(function (field) {\n  // We don't really know the types here, so we add them later instead\n  ;\n\n  singletonRouter[field] = function () {\n    var router = getRouter();\n    return router[field].apply(router, arguments);\n  };\n});\nrouterEvents.forEach(function (event) {\n  singletonRouter.ready(function () {\n    _router2[\"default\"].events.on(event, function () {\n      var eventField = \"on\".concat(event.charAt(0).toUpperCase()).concat(event.substring(1));\n      var _singletonRouter = singletonRouter;\n\n      if (_singletonRouter[eventField]) {\n        try {\n          _singletonRouter[eventField].apply(_singletonRouter, arguments);\n        } catch (err) {\n          console.error(\"Error when running the Router event: \".concat(eventField));\n          console.error(\"\".concat(err.message, \"\\n\").concat(err.stack));\n        }\n      }\n    });\n  });\n});\n\nfunction getRouter() {\n  if (!singletonRouter.router) {\n    var message = 'No router instance found.\\n' + 'You should only use \"next/router\" inside the client side of your app.\\n';\n    throw new Error(message);\n  }\n\n  return singletonRouter.router;\n} // Export the singletonRouter and this is the public API.\n\n\nvar _default = singletonRouter; // Reexport the withRoute HOC\n\nexports[\"default\"] = _default;\n\nfunction useRouter() {\n  _s();\n\n  return _react[\"default\"].useContext(_routerContext.RouterContext);\n} // INTERNAL APIS\n// -------------\n// (do not use following exports inside the app)\n// Create a router and assign it as the singleton instance.\n// This is used in client side when we are initilizing the app.\n// This should **not** use inside the server.\n\n\n_s(useRouter, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\n\nvar createRouter = function createRouter() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  singletonRouter.router = _construct(_router2[\"default\"], args);\n  singletonRouter.readyCallbacks.forEach(function (cb) {\n    return cb();\n  });\n  singletonRouter.readyCallbacks = [];\n  return singletonRouter.router;\n}; // This function is used to create the `withRouter` router instance\n\n\nexports.createRouter = createRouter;\n\nfunction makePublicRouterInstance(router) {\n  var _router = router;\n  var instance = {};\n\n  var _iterator = _createForOfIteratorHelper(urlPropertyFields),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var property = _step.value;\n\n      if (typeof _router[property] === 'object') {\n        instance[property] = Object.assign({}, _router[property]); // makes sure query is not stateful\n\n        continue;\n      }\n\n      instance[property] = _router[property];\n    } // Events is a static property on the router, the router doesn't have to be initialized to use it\n\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  instance.events = _router2[\"default\"].events;\n  coreMethodFields.forEach(function (field) {\n    instance[field] = function () {\n      return _router[field].apply(_router, arguments);\n    };\n  });\n  return instance;\n}","map":{"version":3,"sources":["../../client/router.ts"],"names":["urlPropertyFields","Object","get","router","forEach","singletonRouter","instance"],"mappings":"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","sourcesContent":["/* global window */\nimport React from 'react'\nimport Router, { NextRouter } from '../next-server/lib/router/router'\nimport { RouterContext } from '../next-server/lib/router-context'\n\ntype ClassArguments<T> = T extends new (...args: infer U) => any ? U : any\n\ntype RouterArgs = ClassArguments<typeof Router>\n\ntype SingletonRouterBase = {\n  router: Router | null\n  readyCallbacks: Array<() => any>\n  ready(cb: () => any): void\n}\n\nexport { Router, NextRouter }\n\nexport type SingletonRouter = SingletonRouterBase & NextRouter\n\nconst singletonRouter: SingletonRouterBase = {\n  router: null, // holds the actual router instance\n  readyCallbacks: [],\n  ready(cb: () => void) {\n    if (this.router) return cb()\n    if (typeof window !== 'undefined') {\n      this.readyCallbacks.push(cb)\n    }\n  },\n}\n\n// Create public properties and methods of the router in the singletonRouter\nconst urlPropertyFields = [\n  'pathname',\n  'route',\n  'query',\n  'asPath',\n  'components',\n  'isFallback',\n  'basePath',\n]\nconst routerEvents = [\n  'routeChangeStart',\n  'beforeHistoryChange',\n  'routeChangeComplete',\n  'routeChangeError',\n  'hashChangeStart',\n  'hashChangeComplete',\n]\nconst coreMethodFields = [\n  'push',\n  'replace',\n  'reload',\n  'back',\n  'prefetch',\n  'beforePopState',\n]\n\n// Events is a static property on the router, the router doesn't have to be initialized to use it\nObject.defineProperty(singletonRouter, 'events', {\n  get() {\n    return Router.events\n  },\n})\n\nurlPropertyFields.forEach((field) => {\n  // Here we need to use Object.defineProperty because, we need to return\n  // the property assigned to the actual router\n  // The value might get changed as we change routes and this is the\n  // proper way to access it\n  Object.defineProperty(singletonRouter, field, {\n    get() {\n      const router = getRouter() as any\n      return router[field] as string\n    },\n  })\n})\n\ncoreMethodFields.forEach((field) => {\n  // We don't really know the types here, so we add them later instead\n  ;(singletonRouter as any)[field] = (...args: any[]) => {\n    const router = getRouter() as any\n    return router[field](...args)\n  }\n})\n\nrouterEvents.forEach((event) => {\n  singletonRouter.ready(() => {\n    Router.events.on(event, (...args) => {\n      const eventField = `on${event.charAt(0).toUpperCase()}${event.substring(\n        1\n      )}`\n      const _singletonRouter = singletonRouter as any\n      if (_singletonRouter[eventField]) {\n        try {\n          _singletonRouter[eventField](...args)\n        } catch (err) {\n          console.error(`Error when running the Router event: ${eventField}`)\n          console.error(`${err.message}\\n${err.stack}`)\n        }\n      }\n    })\n  })\n})\n\nfunction getRouter(): Router {\n  if (!singletonRouter.router) {\n    const message =\n      'No router instance found.\\n' +\n      'You should only use \"next/router\" inside the client side of your app.\\n'\n    throw new Error(message)\n  }\n  return singletonRouter.router\n}\n\n// Export the singletonRouter and this is the public API.\nexport default singletonRouter as SingletonRouter\n\n// Reexport the withRoute HOC\nexport { default as withRouter } from './with-router'\n\nexport function useRouter(): NextRouter {\n  return React.useContext(RouterContext)\n}\n\n// INTERNAL APIS\n// -------------\n// (do not use following exports inside the app)\n\n// Create a router and assign it as the singleton instance.\n// This is used in client side when we are initilizing the app.\n// This should **not** use inside the server.\nexport const createRouter = (...args: RouterArgs): Router => {\n  singletonRouter.router = new Router(...args)\n  singletonRouter.readyCallbacks.forEach((cb) => cb())\n  singletonRouter.readyCallbacks = []\n\n  return singletonRouter.router\n}\n\n// This function is used to create the `withRouter` router instance\nexport function makePublicRouterInstance(router: Router): NextRouter {\n  const _router = router as any\n  const instance = {} as any\n\n  for (const property of urlPropertyFields) {\n    if (typeof _router[property] === 'object') {\n      instance[property] = Object.assign({}, _router[property]) // makes sure query is not stateful\n      continue\n    }\n\n    instance[property] = _router[property]\n  }\n\n  // Events is a static property on the router, the router doesn't have to be initialized to use it\n  instance.events = Router.events\n\n  coreMethodFields.forEach((field) => {\n    instance[field] = (...args: any[]) => {\n      return _router[field](...args)\n    }\n  })\n\n  return instance\n}\n"]},"metadata":{},"sourceType":"script"}